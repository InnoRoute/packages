Index: linux-4.4.112/include/linux/skbuff.h 
===================================================================
--- linux-4.4.112.orig/include/linux/skbuff.h
+++ linux-4.4.112/include/linux/skbuff.h
@@ -709,6 +709,7 @@ struct sk_buff {
 				*data;
 	unsigned int		truesize;
 	atomic_t		users;
+	__u32			TN_extended;
 };
 
 #ifdef __KERNEL__
Index: linux-4.4.112/include/uapi/linux/if_packet.h
===================================================================
--- linux-4.4.112.orig/include/uapi/linux/if_packet.h
+++ linux-4.4.112/include/uapi/linux/if_packet.h
@@ -59,6 +59,7 @@ struct sockaddr_ll {
 #define PACKET_ROLLOVER_STATS		21
 #define PACKET_FANOUT_DATA		22
 #define PACKET_RECV_TYPE		23
+#define PACKET_INR_EXT			666  //devil is in the detail
 
 #define PACKET_FANOUT_HASH		0
 #define PACKET_FANOUT_LB		1
Index: linux-4.4.112/net/packet/af_packet.c
===================================================================
--- linux-4.4.112.orig/net/packet/af_packet.c
+++ linux-4.4.112/net/packet/af_packet.c
@@ -2540,7 +2540,7 @@ static int tpacket_snd(struct packet_soc
 		skb = sock_alloc_send_skb(&po->sk,
 				hlen + tlen + sizeof(struct sockaddr_ll),
 				!need_wait, &err);
-
+		
 		if (unlikely(skb == NULL)) {
 			/* we assume the socket was initially writeable ... */
 			if (likely(len_sum > 0))
@@ -2567,7 +2567,7 @@ static int tpacket_snd(struct packet_soc
 				goto out_status;
 			}
 		}
-
+		
 		packet_pick_tx_queue(dev, skb);
 
 		skb->destructor = tpacket_destruct_skb;
@@ -2634,6 +2634,7 @@ static struct sk_buff *packet_alloc_skb(
 	skb_put(skb, linear);
 	skb->data_len = len - linear;
 	skb->len += len - linear;
+	skb->TN_extended=sk->INR_EXT;
 
 	return skb;
 }
@@ -3544,7 +3545,7 @@ packet_setsockopt(struct socket *sock, i
 
 	if (level != SOL_PACKET)
 		return -ENOPROTOOPT;
-
+	
 	switch (optname) {
 	case PACKET_ADD_MEMBERSHIP:
 	case PACKET_DROP_MEMBERSHIP:
@@ -3758,6 +3759,16 @@ packet_setsockopt(struct socket *sock, i
 		po->xmit = val ? packet_direct_xmit : dev_queue_xmit;
 		return 0;
 	}
+	case PACKET_INR_EXT:
+	{	int val;
+
+		if (optlen != sizeof(val))
+			return -EINVAL;
+		if (copy_from_user(&val, optval, sizeof(val)))
+			return -EFAULT;
+		sk->INR_EXT=val;
+		return 0;
+	}
         case PACKET_RECV_TYPE:
         {
                 unsigned int val;
@@ -3882,6 +3893,9 @@ static int packet_getsockopt(struct sock
 	case PACKET_QDISC_BYPASS:
 		val = packet_use_direct_xmit(po);
 		break;
+	case PACKET_INR_EXT:
+		val = sk->INR_EXT;
+		break;
 	default:
 		return -ENOPROTOOPT;
 	}
Index: linux-4.4.112/include/net/sock.h
===================================================================
--- linux-4.4.112.orig/include/net/sock.h
+++ linux-4.4.112/include/net/sock.h
@@ -241,6 +241,7 @@ struct sock_common {
 		u32		skc_tw_snd_nxt; /* struct tcp_timewait_sock */
 	};
 	/* public: */
+	uint16_t INR_EXT;
 };
 
 struct cg_proto;
@@ -457,6 +458,8 @@ struct sock {
 	int			(*sk_backlog_rcv)(struct sock *sk,
 						  struct sk_buff *skb);
 	void                    (*sk_destruct)(struct sock *sk);
+	uint16_t		INR_EXT;
+	
 };
 
 #define __sk_user_data(sk) ((*((void __rcu **)&(sk)->sk_user_data)))
Index: linux-4.4.112/net/core/skbuff.c
===================================================================
--- linux-4.4.112.orig/net/core/skbuff.c
+++ linux-4.4.112/net/core/skbuff.c
@@ -250,6 +250,7 @@ struct sk_buff *__alloc_skb(unsigned int
 	atomic_set(&skb->users, 1);
 	skb->head = data;
 	skb->data = data;
+	skb->TN_extended=0;
 	skb_reset_tail_pointer(skb);
 	skb->end = skb->tail + size;
 	skb->mac_header = (typeof(skb->mac_header))~0U;
